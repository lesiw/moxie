package main

// offsets
// 1: package name
// 2: type
const headerstart = `// Code generated by lesiw.io/moxie. DO NOT EDIT.

package %[1]s

import()

var _%[2]s = new(sync.Map)

type _%[2]sData struct {
	mutex sync.Mutex
    once sync.Once
`

// offsets
// 1: type
// 2: method name
// 3: method signature
const funcinfo = `	%[2]sMock func%[3]s
	%[2]sCalls []_%[1]s_%[2]sCall
`

const headerend = `}

`

// 1: type
// 2: method name
// 3: structified parameters
// 4: structified results
const calltype = `type _%[1]s_%[2]sCall struct {
%[3]s
}

type _%[1]s_%[2]sReturn struct {
%[4]s
}

`

// offsets
// 1: type
// 2: method name
// 3: method signature
// 4: arguments
// 5: origin type
// 6: call arguments
// 7: parameter types
// 8: result parameters
// 9: result types
// 10: result arguments
// 11: result from struct
//
//nolint:lll
const fn = `func (_recv *%[1]s) %[2]s%[3]s {
	if _recv == nil {
		panic("%[1]s.%[2]s: nil pointer receiver")
	}
	_ptr := uintptr(unsafe.Pointer(_recv))
    var _val any
    defer func() {
        if _val != nil {
	        _dat := _val.(*_%[1]sData)
            _dat.once.Do(func() { runtime.SetFinalizer(_recv, func(_ *%[1]s) { _%[1]s.Delete(_ptr) })})
        }
    }()
	_val, _ = _%[1]s.LoadOrStore(_ptr, new(_%[1]sData))
	_dat := _val.(*_%[1]sData)
	_dat.mutex.Lock()
	_dat.%[2]sCalls = append(_dat.%[2]sCalls, _%[1]s_%[2]sCall{%[6]s})
	_dat.mutex.Unlock()
	if _dat.%[2]sMock != nil {
		return _dat.%[2]sMock(%[4]s)
	}
	return _recv.%[5]s.%[2]s(%[4]s)
}

func (_recv *%[1]s) _%[2]s_Patch() {
	if _recv == nil {
		panic("%[1]s.%[2]s: nil pointer receiver")
	}
	_ptr := uintptr(unsafe.Pointer(_recv))
	_val, _ := _%[1]s.LoadOrStore(_ptr, new(_%[1]sData))
	_dat := _val.(*_%[1]sData)
	_dat.%[2]sMock = func(%[7]s) (%[8]s) {
		return %[10]s
	}
}

func (_recv *%[1]s) _%[2]s_Mock(mock func(%[7]s) (%[9]s)) {
	if _recv == nil {
		panic("%[1]s.%[2]s: nil pointer receiver")
	}
	_ptr := uintptr(unsafe.Pointer(_recv))
	_val, _ := _%[1]s.LoadOrStore(_ptr, new(_%[1]sData))
	_dat := _val.(*_%[1]sData)
	_dat.%[2]sMock = mock
}

func (_recv *%[1]s) _%[2]s_Return(%[8]s) {
	if _recv == nil {
		panic("%[1]s.%[2]s: nil pointer receiver")
	}
	_ptr := uintptr(unsafe.Pointer(_recv))
	_val, _ := _%[1]s.LoadOrStore(_ptr, new(_%[1]sData))
	_dat := _val.(*_%[1]sData)
	_dat.%[2]sMock = func(%[7]s) (%[9]s) {
		return %[10]s
	}
}

func (_recv *%[1]s) _%[2]s_Returns(_rets ..._%[1]s_%[2]sReturn) {
	if _recv == nil {
		panic("%[1]s.%[2]s: nil pointer receiver")
	}
	_ptr := uintptr(unsafe.Pointer(_recv))
	_val, _ := _%[1]s.LoadOrStore(_ptr, new(_%[1]sData))
	_dat := _val.(*_%[1]sData)
    var _count int
	_dat.%[2]sMock = func(%[7]s) (%[9]s) {
        defer func() { _count++ }()
        var _ret _%[1]s_%[2]sReturn
        if _count > len(_rets) {
            _ret = _rets[len(_rets)-1]
        } else {
            _ret = _rets[_count]
        }
		return %[11]s
	}
}

func (_recv *%[1]s) _%[2]s_Calls() []_%[1]s_%[2]sCall {
	if _recv == nil {
		panic("%[1]s.%[2]s: nil pointer receiver")
	}
	_ptr := uintptr(unsafe.Pointer(_recv))
	_val, _ := _%[1]s.LoadOrStore(_ptr, new(_%[1]sData))
	_dat := _val.(*_%[1]sData)
	_dat.mutex.Lock()
	defer _dat.mutex.Unlock()
	return _dat.%[2]sCalls
}

`
